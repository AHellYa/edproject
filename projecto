/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package colas_g1;

import java.util.ArrayList;

/**
 *
 * @author alexa
 * @param <T>
 */
public class ColaA<T> implements ColaADT<T> {

    private T[] pendientes;
    private int inicio;
    private int fin;
    private final int MAX = 20;

    public ColaA() {
        pendientes = (T[]) new Object[MAX];
        inicio = -1;
        fin = -1;
    }

    public ColaA(int maximo) {
        pendientes = (T[]) new Object[maximo];
        inicio = -1;
        fin = -1;

    }

    public boolean estaVacia() {
        return inicio == -1;
    }

    public T consultarPrimero() {
        if (estaVacia()) {
            throw new RuntimeException("No hay datos en la cola");
        }
        return pendientes[inicio];

    }

    private boolean estaLlena() {
        return inicio == 0 && fin == pendientes.length - 1 || fin + 1 == inicio;
    }

    public void expande() {
        T[] masGrande = (T[]) new Object[pendientes.length * 2];
        int n = pendientes.length;

        for (int i = 0; i < n; i++) {
            masGrande[i] = pendientes[(inicio + i)];
        }
        inicio = 0;
        fin = n - 1;
        pendientes = masGrande;

    }

    public void agrega(T nuevo) {
        if (this.estaLlena()) {
            expande();
        }
        fin = (fin + 1) % pendientes.length;
        pendientes[fin] = nuevo;
        if (inicio == -1) {
            inicio = 0;
        }
    }

    public T quita() {
        if (this.estaVacia()) {
            throw new RuntimeException("No hay datos en la cola.");
        }
        T eliminado = pendientes[inicio];
        if (inicio == fin) {//solo un elemento
            inicio = -1;
            fin = -1;
        } else {
            inicio = (inicio + 1) % pendientes.length;
        }
        return eliminado;
    }

    private void toString(int tope, int i, StringBuilder sb) {
        if (i <= tope) {
            int indice = (inicio + i) % pendientes.length;
            sb.append(pendientes[indice].toString()).append(", ");
            toString(tope, i + 1, sb);
        }
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        int tope = fin - inicio;
        if (inicio > fin) {
            tope += pendientes.length + 1;
        }
        sb.append("[");
        if (tope != 0) {
            toString(tope, 0, sb);
        }
        sb.append("]");
        return sb.toString();
    }

    public T consultaultimo() {
        return pendientes[fin];
    }

    public static <T> void colaAPila(ColaADT<T> col, PilaU<T> pil) {
        if (!col.estaVacia()) {
            pil.push(col.quita());
            colaAPila(col, pil);
        }
    }

    public static <T> void pilaACola(ColaADT<T> col, PilaU<T> pil) {
        if (!pil.isEmpty()) {
            col.agrega(pil.pop());
            pilaACola(col, pil);
        }
    }

    public static <T> void invierte(ColaADT<T> col) {
        PilaU pil = new PilaU();
        colaAPila(col, pil);
        pilaACola(col, pil);
    }

    private static <T> void eliminaRepetidos(ColaADT<T> col, T previo, ColaADT<T> aux) {
        if (!col.estaVacia()) {
            if (!previo.equals(col.consultarPrimero())) {
                aux.agrega(previo);
                eliminaRepetidos(col, col.quita(), aux);
            } else {
                col.quita();
                eliminaRepetidos(col, previo, aux);
            }
        } else {
            aux.agrega(previo);
        }
    }

    public T consultaUltimo() {
        if (!estaVacia()) {
            return pendientes[fin];
        }
        throw new RuntimeException();
    }

    protected T getAt(int i) {
        return pendientes[i];
    }

    private void redimencionar(int inicio, int fin) {
        T[] aux = (T[]) new Object[pendientes.length * 2];
        int tope = fin - inicio;
        if (inicio > fin) {
            tope += pendientes.length + 1;
        }
        auxRedimencionar(tope, 0, aux);
        this.inicio = 0;
        this.fin = tope;
        pendientes = aux;
    }

    private void auxRedimencionar(int tope, int i, T[] aux) {
        if (i <= tope) {
            int indice = (inicio + i) % pendientes.length;
            aux[i] = pendientes[indice];
            auxRedimencionar(tope, i + 1, aux);
        }
    }

    public static <T> void copiaCola(ColaADT<T> origen, ColaADT<T> destino) {
        if (!origen.estaVacia()) {
            destino.agrega(origen.quita());
            copiaCola(origen, destino);
        }
    }

    public static <T> void eliminaRepetidos(ColaADT<T> col) {
        if (!col.estaVacia()) {
            ColaADT aux = new ColaA();
            eliminaRepetidos(col, col.quita(), aux);
            copiaCola(aux, col);
        }
    }

    private void multiQuitaNE(int n, ArrayList<T> arr) {
        if (!estaVacia() && n > 0) {
            arr.add(quita());
            multiQuitaNE(n - 1, arr);
        }
    }

    public ArrayList<T> multiQuitaNE(int n) {
        if (!estaVacia()) {
            ArrayList<T> arr = new ArrayList<T>();
            multiQuitaNE(n, arr);
            return arr;
        }
        throw new RuntimeException();
    }

    public ArrayList<T> multiQuita(int n) {
        if (cuentaElementos() >= n) {
            ArrayList<T> arr = new ArrayList<T>();
            for (int i = 0; i < n; i++) {
                arr.add(quita());
            }
            return arr;
        }
        throw new RuntimeException();
    }

    public int cuentaElementos() {
        int tope = 0;
        if (!estaVacia()) {
            tope = fin - inicio;
            if (inicio > fin) {
                tope += pendientes.length;
            }
            tope++;
        }
        return tope;
    }

    private static <T> void eliminaCoincidencias(ColaADT<T> col, T elemento, ColaADT<T> aux) {
        if (!col.estaVacia()) {
            if (!elemento.equals(col.consultarPrimero())) {
                aux.agrega(col.quita());
            } else {
                col.quita();
            }
            eliminaCoincidencias(col, elemento, aux);
        }
    }

    public static <T> void eliminaCoincidencias(ColaADT<T> col, T elemento) {
        if (!col.estaVacia()) {
            ColaA aux = new ColaA();
            eliminaCoincidencias(col, elemento, col);
            copiaCola(aux, col);
        }
    }

    public T[] getPendientes() {
        return pendientes;
    }

    protected void setAt(T ele, int i) {
        pendientes[i] = ele;
    }

    public int tamanio() {
        return pendientes.length;
    }

    public int getInicio() {
        return inicio;
    }

    public void setInicio(int inicio) {
        this.inicio = inicio;
    }

    public int getFin() {
        return fin;
    }

    public void setFin(int fin) {
        this.fin = fin;
    }

    protected void agregaInicio(T elemento) {
        if (inicio != -1) {
            if ((fin + 1) % pendientes.length == inicio) {
                redimencionar(inicio, fin);
            }
            inicio = (inicio - 1) % pendientes.length;
            pendientes[inicio] = elemento;
        }
    }

 public static void main(String[] args){
     
     
     ColaA<Integer> c1 = new ColaA(5);
     
     c1.agrega(2);
     c1.agrega(3);
     c1.agrega(4);
     c1.agrega(5);
     c1.agrega(6);
     c1.agrega(7);
     
    System.out.println(c1.toString());
       System.out.println(c1.tamanio());
    }
}


